const mongoose = require('mongoose');

const refundSchema = new mongoose.Schema({  refundId: {
    type: String,
    unique: true,
    required: false // Will be auto-generated by pre-save middleware
  },
  booking: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Booking',
    required: true
  },
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  vendor: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Vendor',
    required: true
  },
  originalAmount: {
    type: Number,
    required: true,
    min: 0
  },
  platformFee: {
    type: Number,
    required: true,
    min: 0,
    default: 5
  },
  refundCalculation: {
    baseRefundAmount: {
      type: Number,
      required: true,
      min: 0
    },
    slotOccupancyFee: {
      type: Number,
      required: true,
      min: 0
    },
    slotOccupancyFeePercentage: {
      type: Number,
      default: 5, // 5% slot occupancy fee
      min: 0,
      max: 100
    },
    platformFeeDeducted: {
      type: Number,
      required: true,
      min: 0
    },
    finalRefundAmount: {
      type: Number,
      required: true,
      min: 0
    }
  },
  cancellationDetails: {
    hoursBeforeCharge: {
      type: Number,
      required: true,
      min: 0
    },
    cancellationReason: {
      type: String,
      required: true,
      trim: true,
      maxlength: 500
    },
    cancelledAt: {
      type: Date,
      required: true,
      default: Date.now
    },
    isEligibleForRefund: {
      type: Boolean,
      required: true,
      default: false
    }
  },
  refundStatus: {
    type: String,
    enum: ['pending', 'processing', 'completed', 'failed', 'rejected'],
    default: 'pending'
  },
  paymentDetails: {
    originalPaymentId: String,
    originalTransactionId: String,
    refundTransactionId: String,
    refundMethod: {
      type: String,
      enum: ['original_payment_method', 'bank_transfer', 'wallet'],
      default: 'original_payment_method'
    },
    gatewayResponse: mongoose.Schema.Types.Mixed
  },
  securityValidation: {
    userIpAddress: String,
    userAgent: String,
    requestSignature: String, // Hash of critical request data
    validatedAt: Date,
    validatedBy: {
      type: String,
      enum: ['system', 'admin'],
      default: 'system'
    }
  },
  processedBy: {
    type: String,
    enum: ['system', 'admin', 'vendor'],
    default: 'system'
  },
  processedAt: Date,
  rejectionReason: {
    type: String,
    trim: true,
    maxlength: 500
  },  auditTrail: {
    type: [{
      action: {
        type: String,
        required: true,
        enum: ['created', 'approved', 'rejected', 'processed', 'failed', 'completed']
      },
      performedBy: {
        type: String,
        required: true
      },
      performedAt: {
        type: Date,
        default: Date.now
      },
      details: String,
      metadata: mongoose.Schema.Types.Mixed
    }],
    default: []
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes
refundSchema.index({ refundId: 1 }, { unique: true });
refundSchema.index({ booking: 1 });
refundSchema.index({ user: 1, createdAt: -1 });
refundSchema.index({ refundStatus: 1 });
refundSchema.index({ createdAt: -1 });

// Virtual for processing time
refundSchema.virtual('processingTime').get(function() {
  if (this.processedAt) {
    return this.processedAt - this.createdAt;
  }
  return null;
});

// Pre-save middleware to generate refund ID
refundSchema.pre('save', function(next) {
  if (!this.refundId) {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 5);
    this.refundId = `RF${timestamp}${random}`.toUpperCase();
  }
  next();
});

// Static method to calculate refund amount
refundSchema.statics.calculateRefundAmount = function(originalAmount, platformFee, hoursBeforeCharge) {
  // Only refundable if more than 6 hours before charging time
  if (hoursBeforeCharge <= 6) {
    return {
      isEligible: false,
      baseRefundAmount: 0,
      slotOccupancyFee: 0,
      platformFeeDeducted: platformFee,
      finalRefundAmount: 0,
      reason: 'Cancellation not allowed within 6 hours of charging time'
    };
  }

  // Calculate refund: Original amount - Platform fee - 5% slot occupancy fee
  const amountAfterPlatformFee = originalAmount - platformFee;
  const slotOccupancyFeePercentage = 5; // 5%
  const slotOccupancyFee = (amountAfterPlatformFee * slotOccupancyFeePercentage) / 100;
  const finalRefundAmount = amountAfterPlatformFee - slotOccupancyFee;

  return {
    isEligible: true,
    baseRefundAmount: amountAfterPlatformFee,
    slotOccupancyFee: slotOccupancyFee,
    slotOccupancyFeePercentage: slotOccupancyFeePercentage,
    platformFeeDeducted: platformFee,
    finalRefundAmount: Math.max(0, finalRefundAmount),
    reason: 'Eligible for refund with applicable deductions'
  };
};

// Instance method to add audit entry
refundSchema.methods.addAuditEntry = function(action, performedBy, details = '', metadata = {}) {
  this.auditTrail.push({
    action,
    performedBy,
    details,
    metadata,
    performedAt: new Date()
  });
  return this.save();
};

module.exports = mongoose.model('Refund', refundSchema);
